generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ====================== ENUMS ======================

enum UserRole {
  chairman
  country_manager
  finance
  legal
  hr
  admin
  it
  councilor
  volunteer
  viewer
}

enum ApprovedStatus {
  rejected
  approved
  pending
}

enum ProjectStatus {
  planned
  active
  completed
  on_hold
  cancelled
}

enum DonationMethod {
  online
  bank
  cash
  cheque
}

enum DonationStatus {
  pending
  completed
  refunded
}

enum ExpenseStatus {
  pending
  approved
  rejected
}

enum ExpenseCategory {
  temple_maintenance
  festival_event
  charity_support
  education_support
  medical_assistance
  food_prasad
  travel_transport
  office_supplies
  staff_salary
  utility_bills
  construction_renovation
  miscellaneous
  project
}

enum PersonType {
  individual
  organization
  government
}

enum LegalCaseStatus {
  open
  in_progress
  on_hold
  escalated
  won
  lost
  settled
  closed
}

enum LegalCategory {
  land
  financial
  employment
  fraud
  harassment
  property
  organizational
  dispute
  compliance
  other
}

enum LegalPriority {
  low
  medium
  high
  urgent
}

enum NoteVisibility {
  internal
  public
}

// ====================== MODELS ======================

// 1. User
model User {
  id           String    @id @default(uuid())
  fullName     String
  email        String    @unique
  phone        String?   @unique
  password     String
  refreshToken String?
  role         UserRole  @default(volunteer)
  countryId    String
  country      Country   @relation(fields: [countryId], references: [id])
  provinceId   String?
  province     Province? @relation(fields: [provinceId], references: [id])
  isActive     Boolean   @default(true)
  lastLogin    DateTime?
  avatarUrl    String?
  metadata     Json?
  address      String

  // Project Relations
  projectId        String?
  project          Project?  @relation("UserProject", fields: [projectId], references: [id])
  managedProjects  Project[] @relation("ManagerProjects")
  assignedProjects Project[] @relation("ProjectWorkers")

  // Transaction Relations
  submittedExpenses Expense[] @relation("SubmittedExpenses")
  approvedExpenses  Expense[] @relation("ApprovedExpenses")

  // Log & Communication Relations
  auditLogs        AuditLog[]
  notifications    Notification[]
  messagesSent     Message[]      @relation("MessagesFrom")
  messagesReceived Message[]      @relation("MessagesTo")
  eventsOrganized  Event[]        @relation("OrganizerEvents")
  assets           Asset[]
  ticketsRequested Ticket[]       @relation("RequestedTickets")
  ticketsAssigned  Ticket[]       @relation("AssignedTickets")

  // Legal Case Reverse Relations (FIXED)
  applicantCases     LegalCase[] @relation("ApplicantCases")
  respondentCases    LegalCase[] @relation("RespondentCases")
  assignedLegalCases LegalCase[] @relation("AssignedLegalCases")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 2. Country 
model Country {
  id          String      @id @default(uuid())
  countryName String
  code        String
  users       User[]
  schools     School[]
  projects    Project[]
  provinces   Province[]
  legalCases  LegalCase[] // Correct reverse relation
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  Expense     Expense[]
  donations   Donation[]
}

// 3. Province
model Province {
  id         String      @id @default(uuid())
  name       String
  code       String
  users      User[]
  countryId  String
  country    Country     @relation(fields: [countryId], references: [id])
  schools    School[]
  projects   Project[]
  legalCases LegalCase[] // Correct reverse relation
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
}

// 4. School
model School {
  id           String    @id @default(uuid())
  name         String
  provinceId   String?
  province     Province? @relation(fields: [provinceId], references: [id])
  address      String?
  studentCount Int?
  countryId    String
  country      Country   @relation(fields: [countryId], references: [id])
  contactName  String?
  contactPhone String?
  contactEmail String?
  photos       String[] // Cloudinary URLs
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
}

// 5. Project
model Project {
  id          String         @id @default(uuid())
  title       String
  approved    ApprovedStatus @default(pending)
  description String?
  provinceId  String?
  province    Province?      @relation(fields: [provinceId], references: [id])
  managerId   String?
  manager     User?          @relation("ManagerProjects", fields: [managerId], references: [id])
  status      ProjectStatus
  startDate   DateTime?
  endDate     DateTime?

  // ðŸ”§ Workers (many-to-many)
  workers User[] @relation("ProjectWorkers")

  // ðŸ”§ New: Reverse of User.project
  assignedUsers User[] @relation("UserProject")

  budget    Float?
  spent     Float      @default(0)
  documents String[]
  donations Donation[]
  expenses  Expense[]
  countryId String
  country   Country    @relation(fields: [countryId], references: [id])
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@index([provinceId])
  @@index([managerId])
}

// 6. Donation
model Donation {
  id         String         @id @default(uuid())
  donorName  String
  donorEmail String?
  donorPhone String?
  countryId  String
  country    Country        @relation(fields: [countryId], references: [id])
  amount     Float
  method     DonationMethod @default(cash)
  status     DonationStatus @default(completed)
  receivedAt DateTime?
  projectId  String?
  project    Project?       @relation(fields: [projectId], references: [id])
  receiptUrl String?
  note       String?
  invoiceNo  String?
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  @@index([receivedAt])
  @@index([status])
  @@index([projectId])
}

// 7. Expense
model Expense {
  id            String          @id @default(uuid())
  amount        Float
  category      ExpenseCategory
  projectId     String?
  project       Project?        @relation(fields: [projectId], references: [id])
  submittedById String?
  submittedBy   User?           @relation("SubmittedExpenses", fields: [submittedById], references: [id])
  approvedById  String?
  approvedBy    User?           @relation("ApprovedExpenses", fields: [approvedById], references: [id])
  status        ExpenseStatus
  invoiceUrl    String[]
  countryId     String
  country       Country         @relation(fields: [countryId], references: [id])
  date          DateTime?
  notes         String?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  @@index([projectId, status])
}

// 8. AuditLog (immutable)
model AuditLog {
  id             String   @id @default(uuid())
  actorId        String?
  actor          User?    @relation(fields: [actorId], references: [id])
  action         String
  collectionName String
  documentId     String
  before         Json?
  after          Json?
  createdAt      DateTime @default(now())
}

// 9. Notification
model Notification {
  id        String   @id @default(uuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  channel   String // email, sms, in_app, whatsapp
  title     String
  body      String
  read      Boolean  @default(false)
  meta      Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 10. Message (Chat / Communication)
model Message {
  id          String   @id @default(uuid())
  fromUserId  String?
  fromUser    User?    @relation("MessagesFrom", fields: [fromUserId], references: [id])
  toUserId    String?
  toUser      User?    @relation("MessagesTo", fields: [toUserId], references: [id])
  groupId     String?
  subject     String?
  body        String
  channel     String // 'email' | 'whatsapp' | 'internal'
  isRead      Boolean  @default(false)
  meta        Json?
  attachments String[] // Cloudinary URLs
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([toUserId])
  @@index([fromUserId])
}

// 11. Event
model Event {
  id          String    @id @default(uuid())
  title       String
  description String?
  startAt     DateTime
  endAt       DateTime?
  organizerId String?
  organizer   User?     @relation("OrganizerEvents", fields: [organizerId], references: [id])
  attendees   Json? // [{id, name, status}]
  location    String?
  attachments String[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

// 12. Asset
model Asset {
  id           String    @id @default(uuid())
  name         String
  type         String
  location     String?
  ownerId      String?
  owner        User?     @relation(fields: [ownerId], references: [id])
  purchaseDate DateTime?
  serialNo     String?
  status       String
  notes        String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
}

// 13. Ticket
model Ticket {
  id          String   @id @default(uuid())
  title       String
  description String?
  requesterId String?
  requester   User?    @relation("RequestedTickets", fields: [requesterId], references: [id])
  assigneeId  String?
  assignee    User?    @relation("AssignedTickets", fields: [assigneeId], references: [id])
  priority    String? // 'low' | 'medium' | 'high'
  status      String // 'open' | 'in_progress' | 'closed'
  logs        Json?
  attachments String[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([status])
}

// 14. LegalCase
model LegalCase {
  id          String          @id @default(uuid())
  caseNumber  String?         @unique
  title       String
  description String?
  category    LegalCategory
  priority    LegalPriority   @default(medium)
  status      LegalCaseStatus @default(open)

  // Parties (User relations, using explicit names)
  applicantId String?
  applicant   User?   @relation("ApplicantCases", fields: [applicantId], references: [id])

  respondentId String?
  respondent   User?   @relation("RespondentCases", fields: [respondentId], references: [id])

  // Assigned Legal Officer / Lawyer
  assignedToId String?
  assignedTo   User?   @relation("AssignedLegalCases", fields: [assignedToId], references: [id])

  // Location (Unnamed relations, reverse fields handled in Country/Province)
  countryId String
  country   Country @relation(fields: [countryId], references: [id])

  provinceId String?
  province   Province? @relation(fields: [provinceId], references: [id])

  // Timeline
  filingDate   DateTime?
  hearingDates DateTime[]
  closedDate   DateTime?

  // Attachments
  documents String[]
  notes     String[]
  logs      Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([status])
  @@index([assignedToId])
}
